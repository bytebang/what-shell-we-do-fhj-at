// pipe[0] zum Lesen und pipe[1] zum Schreiben
	int pipe_verbindung_A[2];
	int pipe_verbindung_B[2];

	//Initialisierung durch die Funktion Pipe
	//pipe(pipe_verbindung_A);

	int cid1;
	int cid2;
	int cid3;

	// Prozesse erzeugen

	// Noch haben wir einen Prozess
	// Wir setzen die erste Pipe auf
	pipe(pipe_verbindung_A);
	cid1 = fork();
	if(cid1== 0)
	{
		// im Kindprozess
		LOG("Das ist der erste Prozess");
		// dup2 verbindet den Filedeskriptor der Pipe mit der Filedeskriptor der Standardausgabe
		dup2(pipe_verbindung_A[PWRITE],STDOUT_FILENO);

		// der Leseausgang muss geschlossen werden, da dieser Prozess nichts liest
		close(pipe_verbindung_A[PREAD]);

		 // Kommando ausf√ºhren, Standardausgabe des Kommandos ist mit der Pipe verbunden
		execlp("ls","ls",0);
	}
	else
	{
		// im Elternprozess
		pipe(pipe_verbindung_B);
		cid2 = fork();
		if(cid2 == 0)
		{
			// im Kindprozess
			LOG("Das ist der zweite Prozess");
			dup2(pipe_verbindung_A[PREAD],STDIN_FILENO); // Alles aus der Pipe geht in die stdin
			close(pipe_verbindung_A[PWRITE]);

			dup2(pipe_verbindung_B[PWRITE],STDOUT_FILENO);
			close(pipe_verbindung_B[PREAD]);

			execlp("sort","sort","-r",0);
		}
		else //if (1==2)
		{
			// im Elternprozess
			cid3 = fork();
			if(cid3 == 0)
			{
				// im Kindprozess

				close(pipe_verbindung_A[PWRITE]);

				LOG("Das ist der dritte Prozess");
				dup2(pipe_verbindung_B[PREAD],STDIN_FILENO);
				close(pipe_verbindung_B[PWRITE]);
				execlp("wc","wc",0);
			}
		}
	}



	//Kindprozess erzeugen
	if (cid1==0)
	{

	}
	// dann zweiten Kindprozess erzeugen
	if (cid2==0)
	{

	}
	if(1==1)
	{
		// Dritten Kindprozess erzeugen
		if (cid3==0)
		{
			LOG("Das ist der dritte Prozess");
	        dup2(pipe_verbindung_B[PREAD],STDIN_FILENO);
	        close(pipe_verbindung_B[PWRITE]);
	        execlp("wc","wc",0);
	    }

	}
	exit(0);